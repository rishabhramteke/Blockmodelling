function [cmAdjMat, vVertPos, ccvImageGraphPlantedWeights, cmShuffledAdjMat, vShuffledVertPos] =...
        genWeightedBlockmodelWithBackground(sPosDist, posNum, graphSize, bShuffle, sBlockmodelType,...
            varargin)
%
% Generate weighted blockmodels, using a stocastic blockmodel (generative) model.
% Compared to genBlockmodel, this version does not generate a background noise
% (TODO: how to do this in a consistent way for weighted blockmodels).
%
% It also allows generation of different predefined structure (like the newman
% version).  At the moment, these are: community, core-periphery, hierarchy,
% bipartite and random (as before).  
%
% @author Jeffrey Chan
% @Date 1/2013
%
% sPosDist - probability distribution of the sizes of each position/role
% posNum - number of roles to generate
% graphSize - number of vertices in the graph generated
% bShuffle - whether to shuffle the generated adjacency matrix
% sBlockmodelType - the type of blockmodel to generate (community,
% corePeriphery, hierarchy, bipartite, random).
%
% Optional:
% 
%
% mAdjMat - (unshuffled) generated adajency matrix.
% vVertRole - mapping of vertices to roles.
% mShuffledAdjMat - shuffled adajency matrix.
% vShuffledVertRole - shuffled vertices to roles mapping.
%

    mystream = RandStream('mt19937ar','Seed',sum(100*clock));
    RandStream.setGlobalStream(mystream);

    optargin = size(varargin,2);
    stdargin = nargin - optargin;

    if stdargin < 4
        disp(' genWeightedBlockmodelWithBackground(vRoleProb, graphSize, bShuffle, sBlockmodelType, varargin)');
        exit;
    end


    % if image matrix missing, we generate it
    if optargin > 0
        % first argument will determine what should be done
        % generate image matrix
        % one image matrix will be generated per entry of vMeanDense
        vMeanDense = varargin{1};
        vVarDense = varargin{2};
        ccDenseBlockParams = varargin{3};
        meanSparse = varargin{4};
        stdSparse = varargin{5};
        cSparseBlockParams = varargin{6};
        cOptional = [];
        if strcmp(sBlockmodelType, 'random')
            probDense = varargin{7};            
            cOptional = [probDense];
        elseif strcmp(sBlockmodelType, 'corePeriphery')
            stepSize = varargin{7};
            cOptional = [stepSize];
        end
        ccImageGraphPlanted = genImageGraphPlanted(sBlockmodelType, posNum, vMeanDense, vVarDense, meanSparse, stdSparse,...
            ccDenseBlockParams, cSparseBlockParams, cOptional);
    end


    % generate role sizes
    [vPosNum, vVertPos] = genPositionMembership(sPosDist, posNum, graphSize);

    assert(size(vPosNum,2) == size(ccImageGraphPlanted{1},2));
    assert(size(ccImageGraphPlanted{1},1) == size(ccImageGraphPlanted{1},2));


    % generate the initial graph, using the background image and the input block
    % paramters
    [cmAdjMat, ccvImageGraphPlantedWeights] = genGraph(vPosNum, ccImageGraphPlanted, graphSize);
    
           
    [vShuffledVertPos, cmShuffledAdjMat] = shuffle(bShuffle, vVertPos, cmAdjMat, graphSize);
    



end % end of function



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function [cmImageGraphPlanted, cmDense] = genImageGraphPlanted(sBlockmodelType, posNum, vMeanDense,...
    vStdDense, meanSparse, stdSparse, ccDenseBlockParams, cSparseBlockParas, vOptional)
%
% Generate image matrix.  Each block is either dense or sparse, depending
% on probDense (1 - probDense) respectively.  The density of each block is
% then generated by a gaussian(meanDense, stdDense) for dense (and for
% sparse, we use meanSparse and varSparse).
%
% sBlockmodelType - see description for main function.
% posNum - number of blocks
% meanDense - 
%
% vOptional (vector of extra double parameters):
% For 'random' blockmodelType
%   probDense - probability that a block is dense
% For 'coreperiphery' blockmodelType
%   stepSize - This controls the "skewness" of the core-periphery; i.e., how
%   fast does the dense block rate drop as we go further from the core
%   position?  Set to 0 for all blocks to be dense, 1 for a "typical" core
%   periphery, and higher for greater skewness.
%  
%

    
    switch sBlockmodelType
        case 'community'
            % generate dense diagonal blocks
            mDense = logical(diag(ones(1,posNum), 0));
            cmImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, cSparseBlockParas);     
        case 'corePeriphery'
            % TODO, this will generate a uniform block distributed
            % core-perhipery
            % It might be better to use newman's generation for this type of
            % structure, as it will generate graphs that are closer to reality
            stepSize = vOptional(1);
            mDense = false(posNum, posNum);
            for r = 1 : posNum
                for c = 1 : posNum - (r-1)*stepSize
                    mDense(r,c) = true;
                    mDense(c,r) = true;
                end
            end

            cmImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, cSparseBlockParas);
        case 'hierarchy'
            mDense = false(posNum, posNum);
            
            % this will generate a single 0 image matrix if posNum = 1, as
            % desired.  Otherwise generate an off-diagonal hierarchical image
            % matrix.  Note that for posNum = 2, this generates a biparatite
            % structure.
            for p = 1 : posNum-1
                mDense(p, p+1) = true;
                mDense(p+1, p) = true;
            end
            cmImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, cSparseBlockParas);
        case 'downHierarchy'
            % Hierarchy where a flow goes from top position to next one
            mDense = false(posNum, posNum);
            
            % see notes for hierarchy generation to understand the logical
            % behind this
            for p = 1 : posNum-1
                mDense(p, p+1) = true;
            end
            
            cmImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, ccSparseBlockParams);
        case 'upHierarchy'
            [cmImageGraphPlanted] = genImageGraphPlanted('downHierarchy', probDense, posNum, meanDense, stdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, cSparseBlockParas);
            % upHierarchy is the tranpose of downHierarchy
            for m = 1 : size(cmImageGraphPlanted,2)
                cmImageGraphPlanted{m} = cmImageGraphPlanted{m}';
            end
        case 'random'
            probDense = vOptional(1);
            % generate dense blocks accounding to rand and probDense
            mDense = logical(rand(posNum, posNum) < probDense);
            cmImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
                ccDenseBlockParams, cSparseBlockParas);          
        otherwise
            disp(usage());  
            err = MException('genImageGraphPlanted:InvalidBlockType', 'Invalid blockmodel type specified.');
            throw(err);   
    end

end % end of function


function ccImageGraphPlanted = genBlocks(mDense, vMeanDense, vStdDense, meanSparse, stdSparse,...
    ccDenseBlockParas, cSparseBlockParas)
%
% Generates the block densities for the planted image graph.
%

    
    ccImageGraphPlanted = cell(1, length(ccDenseBlockParas));

    for m = 1 : length(ccDenseBlockParas)
        % 2D cell, with each entry holding a vector of density values
        cImageGraphPlanted = cell(size(mDense,1), size(mDense,2), 2); 

        for c = 1 : size(mDense,2)
            for r = 1 : size(mDense,1)
                if mDense(r,c)
                    density = normrnd(vMeanDense(m), vStdDense(m));
                    if density >= 1.0, density = 1.0; end               
                    cImageGraphPlanted{r,c,1} = density;
                    cImageGraphPlanted{r,c,2} = ccDenseBlockParas{m};
                else
                    density = normrnd(meanSparse, stdSparse);
                    if density >= 1.0, density = 1.0; end     
                    cImageGraphPlanted{r,c,1} = density;
                    cImageGraphPlanted{r,c,2} = cSparseBlockParas;
                end
            end
        end
    
        ccImageGraphPlanted{m} = cImageGraphPlanted;
    end
    
end % end of function








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5


function [vPosNum, vVertPos] = genPositionMembership(sPosDist, posNum, graphSize)
%
% Generate the sizes of each position, based on the distribution specified in
% sPosDist.
%

    switch sPosDist
        case 'uniform'
            vRoleProb = zeros(1,posNum) + 1/posNum;
        case 'linear'
            vRoleProb = [posNum:-1:1]/sum([1:1:posNum]);
        case 'random'
            % generate a random sizes that sum up to graphsize, then we divide by
            % graphsize
            vRoleProb = (randfixedsum(posNum, 1, graphSize, 1, graphSize))' / graphSize;
        otherwise
            disp(usage());
            err = MException('genPositionSize:InvalidPositoinDistribution', 'Invalid role distribution specified.');
            throw(err);
    end
    
    % generate membership of the vertices
    vPosNum = mnrnd(graphSize, vRoleProb);    
    
    % if there are any zero elements, we random sample one of partitions that
    % has more than one element and move an element to each zero element
    % partition
    vZeroSizedRoles = find(vPosNum == 0);
    for zeroi = 1 : size(vZeroSizedRoles,2)
        vNZSizedRoles = find(vPosNum > 1);
        nzChosen = randsample(vNZSizedRoles, 1);   
        vPosNum(nzChosen) = vPosNum(nzChosen) - 1;
        vPosNum(vZeroSizedRoles(zeroi)) = vPosNum(vZeroSizedRoles(zeroi)) + 1;
    end

    % make sure all roles have at least one element
    assert(isempty(find(vPosNum == 0,1)));    
   
    
    % generate vertex to role mapping
    vVertPos = zeros(1, graphSize);
 
    vertIndex = 1;
    for i = 1 : size(vPosNum,2)
        % assign vertex, in order, to each role, based on the numbers from
        % vPosNum
        for j = 1 : vPosNum(i)
            vVertPos(vertIndex) = i;
            vertIndex = vertIndex + 1;
        end
    end
    
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



function [cmAdjMat, ccvImageGraphPlantedWeights] = genGraph(vPosNum, ccImageGraphPlanted, graphSize)
%
% Generates an adjacency matrix accounting to the postion assignments and given
% image matrix.
%
    % adjacency matrix generated
    graphNum = length(ccImageGraphPlanted);
    posNum = size(ccImageGraphPlanted{1},1);
    cmAdjMat = cell(1, graphNum);
    
    ccvImageGraphPlantedWeights = cell(1, graphNum);
    
    for m = 1 : graphNum
        mAdjMat = zeros(graphSize, graphSize);
        cvImageGraphPlantedHist = cell(posNum, posNum);
        currRowShift = 1;
        currColShift = 1;

        % from block generate the number of edges (binomial(p,n), p = density of
        % block/probability of an edge, n = number of elements in the block)
        for r = 1 : posNum
            for c = 1 : posNum
                density = ccImageGraphPlanted{m}{r,c,1};
                cBlockParams = ccImageGraphPlanted{m}{r,c,2};
                
                edgeNum = binornd(vPosNum(r) * vPosNum(c), density);
                vEdges = randsample(vPosNum(r) * vPosNum(c), edgeNum);
                
                % sample edge weigths from appropriate distribution
                switch cBlockParams{1}
                    case 'uniform'
                        minRange = cBlockParams{2};
                        maxRange = cBlockParams{3};
                        vEdgeWeights = randi([minRange, maxRange], 1, edgeNum);
                    case 'lognormal'
                        lognormMean = cBlockParams{2};
                        lognormScale = cBlockParams{3};
                        vEdgeWeights = round(lognrnd(lognormMean, lognormScale, 1, edgeNum));
                    otherwise
                        disp(usage());
                        err = MException('genHistogram:InvalidBlockDistribution', 'Invalid option for block distribution specified.');
                        throw(err);
                end  
                cvImageGraphPlantedHist{r,c} = vEdgeWeights;
                
                % generate the edges
                for e = 1 : length(vEdges)
                    row = floor((vEdges(e) - 1) / vPosNum(c));
                    col = floor(mod((vEdges(e)-1), vPosNum(c)));
                  
                    mAdjMat(currRowShift + row, currColShift + col) = vEdgeWeights(e);
                end
        
                currColShift = currColShift + vPosNum(c);                
        
            end
    
            currRowShift = currRowShift + vPosNum(r);
            currColShift = 1;
        end
        
        cmAdjMat{m} = mAdjMat;
        ccvImageGraphPlantedWeights{m} = cvImageGraphPlantedHist;
    end

end % end of function




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function [vShuffledVertPos, cmShuffledAdjMat] = shuffle(bShuffle, vVertPos, cmAdjMat, graphSize)
%
% Shuffles the matrices.  The same permutations are applied to all the graphs.
%

    shuffleNum = 50;
    % shuffle adjacency matrix (we need to shuffle the actual partitions also)
    % shuffle x number of times
    
    vShuffledVertPos = vVertPos;
    cmShuffledAdjMat = cmAdjMat;
    graphNum = size(cmAdjMat,2);
    
    if bShuffle
        for s = 1 : shuffleNum
            vShuffle = randperm(graphSize);
            % shuffle adjacency matrix
            for m = 1 : graphNum
                for b = 1 : size(cmAdjMat,1)
                    cmShuffledAdjMat{b,m} = cmShuffledAdjMat{b,m}(vShuffle, vShuffle);
                end
            end
            % shuffle mapping
            vShuffledVertPos = vShuffledVertPos(vShuffle);
        end
    end


end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function sUsage = usage()
%
% Returns the usage string.
%
    sUsage = 'Usage: genNewmanBlockmodel(sRoleDist, roleNum, graphSize, sDegDist, degPara, backgroundProp, sBlockmodelType, bShuffle)';
end